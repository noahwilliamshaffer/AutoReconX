"""
Vulnerability Exploiter Module for AutoReconX
Handles SQL injection testing with SQLmap and brute-force attacks with Hydra.
"""

import subprocess
import json
import time
import threading
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urljoin

from utils.logger import get_module_logger, ProgressLogger


class VulnerabilityExploiter:
    """Vulnerability exploiter using SQLmap and Hydra."""
    
    def __init__(self, max_threads=5):
        """
        Initialize the vulnerability exploiter.
        
        Args:
            max_threads (int): Maximum concurrent exploitation threads
        """
        self.max_threads = max_threads
        self.logger = get_module_logger(__name__)
        self.exploit_results = {}
        
        # Common wordlists and dictionaries
        self.common_usernames = [
            'admin', 'administrator', 'root', 'user', 'test', 'guest',
            'demo', 'ftp', 'www', 'web', 'http', 'mail', 'email',
            'service', 'operator', 'manager', 'sa', 'oracle', 'postgres'
        ]
        
        self.common_passwords = [
            'password', '123456', 'admin', 'root', 'password123',
            'admin123', '12345', 'qwerty', 'letmein', 'welcome',
            'monkey', '1234567890', 'password1', 'abc123', 'Password1'
        ]
    
    def check_tool_availability(self, tool_name):
        """Check if a specific tool is available."""
        try:
            result = subprocess.run([tool_name, '--help'], 
                                  capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False
    
    def run_sqlmap_test(self, target_info, output_dir=None):
        """
        Run SQLmap tests on web applications.
        
        Args:
            target_info (dict): Target information from scanner
            output_dir (Path): Directory to save results
            
        Returns:
            dict: SQLmap test results
        """
        if not self.check_tool_availability('sqlmap'):
            self.logger.warning("SQLmap is not available, skipping SQL injection tests")
            return {'status': 'skipped', 'reason': 'SQLmap not available'}
        
        results = {
            'tool': 'sqlmap',
            'targets_tested': [],
            'vulnerabilities_found': [],
            'timestamp': time.time()
        }
        
        # Find web services from scan results
        web_targets = self._identify_web_targets(target_info)
        
        if not web_targets:
            self.logger.info("No web services found for SQL injection testing")
            return {'status': 'skipped', 'reason': 'No web services found'}
        
        self.logger.info(f"Found {len(web_targets)} web targets for SQL injection testing")
        
        # Test each web target
        for target in web_targets:
            self.logger.info(f"Testing SQL injection on {target['url']}")
            
            # Basic SQLmap command
            cmd = [
                'sqlmap', '-u', target['url'],
                '--batch', '--random-agent', '--level=2', '--risk=2',
                '--timeout=30', '--retries=2'
            ]
            
            # Add output directory if specified
            if output_dir:
                session_file = output_dir / f"sqlmap_session_{target['ip'].replace('.', '_')}.sqlite"
                cmd.extend(['--session-file', str(session_file)])
            
            try:
                # Run SQLmap with timeout
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
                
                test_result = {
                    'target': target,
                    'command': ' '.join(cmd),
                    'status': 'completed',
                    'vulnerable': self._parse_sqlmap_output(result.stdout),
                    'output': result.stdout,
                    'error': result.stderr
                }
                
                results['targets_tested'].append(test_result)
                
                if test_result['vulnerable']:
                    results['vulnerabilities_found'].append(test_result)
                    self.logger.warning(f"SQL injection vulnerability found on {target['url']}")
                else:
                    self.logger.info(f"No SQL injection vulnerabilities found on {target['url']}")
                    
            except subprocess.TimeoutExpired:
                self.logger.error(f"SQLmap timeout for {target['url']}")
                results['targets_tested'].append({
                    'target': target,
                    'status': 'timeout',
                    'error': 'Test timeout after 300 seconds'
                })
            except Exception as e:
                self.logger.error(f"SQLmap error for {target['url']}: {str(e)}")
                results['targets_tested'].append({
                    'target': target,
                    'status': 'error',
                    'error': str(e)
                })
        
        results['status'] = 'completed'
        results['total_targets'] = len(web_targets)
        results['vulnerable_targets'] = len(results['vulnerabilities_found'])
        
        return results
    
    def run_hydra_bruteforce(self, target_info, output_dir=None):
        """
        Run Hydra brute-force attacks on discovered services.
        
        Args:
            target_info (dict): Target information from scanner
            output_dir (Path): Directory to save results
            
        Returns:
            dict: Hydra attack results
        """
        if not self.check_tool_availability('hydra'):
            self.logger.warning("Hydra is not available, skipping brute-force attacks")
            return {'status': 'skipped', 'reason': 'Hydra not available'}
        
        results = {
            'tool': 'hydra',
            'targets_attacked': [],
            'successful_attacks': [],
            'timestamp': time.time()
        }
        
        # Find brute-forceable services
        bf_targets = self._identify_bruteforce_targets(target_info)
        
        if not bf_targets:
            self.logger.info("No brute-forceable services found")
            return {'status': 'skipped', 'reason': 'No brute-forceable services found'}
        
        self.logger.info(f"Found {len(bf_targets)} targets for brute-force attacks")
        
        # Create temporary wordlist files
        temp_dir = Path.cwd() / "temp"
        temp_dir.mkdir(exist_ok=True)
        
        userlist_file = temp_dir / "userlist.txt"
        passlist_file = temp_dir / "passlist.txt"
        
        with open(userlist_file, 'w') as f:
            f.write('\n'.join(self.common_usernames))
        
        with open(passlist_file, 'w') as f:
            f.write('\n'.join(self.common_passwords))
        
        try:
            # Attack each target
            for target in bf_targets:
                self.logger.info(f"Brute-forcing {target['service']} on {target['ip']}:{target['port']}")
                
                # Build Hydra command based on service
                cmd = self._build_hydra_command(target, userlist_file, passlist_file, output_dir)
                
                if not cmd:
                    continue
                
                try:
                    # Run Hydra with timeout
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=600)
                    
                    attack_result = {
                        'target': target,
                        'command': ' '.join(cmd),
                        'status': 'completed',
                        'credentials_found': self._parse_hydra_output(result.stdout),
                        'output': result.stdout,
                        'error': result.stderr
                    }
                    
                    results['targets_attacked'].append(attack_result)
                    
                    if attack_result['credentials_found']:
                        results['successful_attacks'].append(attack_result)
                        self.logger.warning(f"Credentials found for {target['service']} on {target['ip']}:{target['port']}")
                    else:
                        self.logger.info(f"No credentials found for {target['service']} on {target['ip']}:{target['port']}")
                        
                except subprocess.TimeoutExpired:
                    self.logger.error(f"Hydra timeout for {target['ip']}:{target['port']}")
                    results['targets_attacked'].append({
                        'target': target,
                        'status': 'timeout',
                        'error': 'Attack timeout after 600 seconds'
                    })
                except Exception as e:
                    self.logger.error(f"Hydra error for {target['ip']}:{target['port']}: {str(e)}")
                    results['targets_attacked'].append({
                        'target': target,
                        'status': 'error',
                        'error': str(e)
                    })
        
        finally:
            # Cleanup temporary files
            try:
                userlist_file.unlink(missing_ok=True)
                passlist_file.unlink(missing_ok=True)
                temp_dir.rmdir()
            except:
                pass
        
        results['status'] = 'completed'
        results['total_targets'] = len(bf_targets)
        results['compromised_targets'] = len(results['successful_attacks'])
        
        return results
    
    def _identify_web_targets(self, target_info):
        """Identify web services for SQL injection testing."""
        web_targets = []
        
        for ip, scan_result in target_info.get('scan_results', {}).items():
            if scan_result.get('status') != 'success':
                continue
                
            ports = scan_result.get('ports', [])
            for port_info in ports:
                port = port_info.get('port')
                service = port_info.get('service', '').lower()
                
                # Common web service ports and services
                if (port in ['80', '443', '8080', '8443', '8000', '9000'] or 
                    'http' in service or 'web' in service):
                    
                    # Determine protocol
                    protocol = 'https' if port in ['443', '8443'] or 'ssl' in service else 'http'
                    url = f"{protocol}://{ip}:{port}/"
                    
                    web_targets.append({
                        'ip': ip,
                        'port': port,
                        'service': service,
                        'url': url
                    })
        
        return web_targets
    
    def _identify_bruteforce_targets(self, target_info):
        """Identify services suitable for brute-force attacks."""
        bf_targets = []
        
        # Services that can be brute-forced
        bruteforceable_services = {
            'ssh': ['22'],
            'ftp': ['21'],
            'telnet': ['23'],
            'smtp': ['25', '587'],
            'pop3': ['110', '995'],
            'imap': ['143', '993'],
            'http': ['80', '8080'],
            'https': ['443', '8443'],
            'mysql': ['3306'],
            'mssql': ['1433'],
            'postgres': ['5432'],
            'vnc': ['5900'],
            'rdp': ['3389']
        }
        
        for ip, scan_result in target_info.get('scan_results', {}).items():
            if scan_result.get('status') != 'success':
                continue
                
            ports = scan_result.get('ports', [])
            for port_info in ports:
                port = port_info.get('port')
                service = port_info.get('service', '').lower()
                
                # Check if service is brute-forceable
                for bf_service, bf_ports in bruteforceable_services.items():
                    if port in bf_ports or bf_service in service:
                        bf_targets.append({
                            'ip': ip,
                            'port': port,
                            'service': bf_service,
                            'detected_service': service
                        })
                        break
        
        return bf_targets
    
    def _build_hydra_command(self, target, userlist, passlist, output_dir):
        """Build Hydra command for specific service."""
        base_cmd = [
            'hydra', '-L', str(userlist), '-P', str(passlist),
            '-t', '4', '-w', '30', '-f'
        ]
        
        # Add output file if specified
        if output_dir:
            output_file = output_dir / f"hydra_{target['ip']}_{target['port']}.txt"
            base_cmd.extend(['-o', str(output_file)])
        
        service = target['service'].lower()
        ip_port = f"{target['ip']}:{target['port']}"
        
        # Service-specific commands
        if service == 'ssh':
            return base_cmd + [ip_port, 'ssh']
        elif service == 'ftp':
            return base_cmd + [ip_port, 'ftp']
        elif service == 'telnet':
            return base_cmd + [ip_port, 'telnet']
        elif service in ['http', 'https']:
            # For web services, try basic auth
            return base_cmd + [ip_port, 'http-get']
        elif service == 'mysql':
            return base_cmd + [ip_port, 'mysql']
        elif service == 'postgres':
            return base_cmd + [ip_port, 'postgres']
        elif service == 'rdp':
            return base_cmd + [ip_port, 'rdp']
        else:
            self.logger.warning(f"No Hydra module available for service: {service}")
            return None
    
    def _parse_sqlmap_output(self, output):
        """Parse SQLmap output to determine if vulnerabilities were found."""
        if not output:
            return False
        
        # Look for positive indicators in SQLmap output
        positive_indicators = [
            'Parameter:',
            'Type:',
            'Title:',
            'Payload:',
            'is vulnerable',
            'sqlmap identified the following injection point'
        ]
        
        for indicator in positive_indicators:
            if indicator in output:
                return True
        
        return False
    
    def _parse_hydra_output(self, output):
        """Parse Hydra output to extract found credentials."""
        credentials = []
        
        if not output:
            return credentials
        
        lines = output.split('\n')
        for line in lines:
            # Look for successful login lines
            if '[' in line and ']' in line and ('login:' in line or 'password:' in line):
                if 'login:' in line and 'password:' in line:
                    # Extract credentials from the line
                    try:
                        parts = line.split()
                        username = None
                        password = None
                        
                        for i, part in enumerate(parts):
                            if part == 'login:' and i + 1 < len(parts):
                                username = parts[i + 1]
                            elif part == 'password:' and i + 1 < len(parts):
                                password = parts[i + 1]
                        
                        if username and password:
                            credentials.append({
                                'username': username,
                                'password': password,
                                'raw_line': line.strip()
                            })
                    except:
                        pass
        
        return credentials
    
    def run_exploitation(self, scan_results, output_dir=None):
        """
        Run comprehensive exploitation on scan results.
        
        Args:
            scan_results (dict): Results from network scanner
            output_dir (Path): Directory to save results
            
        Returns:
            dict: Complete exploitation results
        """
        self.logger.info("Starting vulnerability exploitation phase")
        
        results = {
            'scan_input': scan_results.get('target', 'unknown'),
            'timestamp': time.time(),
            'exploitation_results': {}
        }
        
        # Run SQL injection tests
        self.logger.info("Running SQL injection tests with SQLmap")
        sqlmap_results = self.run_sqlmap_test(scan_results, output_dir)
        results['exploitation_results']['sqlmap'] = sqlmap_results
        
        # Run brute-force attacks
        self.logger.info("Running brute-force attacks with Hydra")
        hydra_results = self.run_hydra_bruteforce(scan_results, output_dir)
        results['exploitation_results']['hydra'] = hydra_results
        
        # Summary statistics
        total_vulns = 0
        if sqlmap_results.get('status') == 'completed':
            vuln_count = sqlmap_results.get('vulnerable_targets', 0)
            total_vulns += vuln_count if isinstance(vuln_count, int) else 0
        if hydra_results.get('status') == 'completed':
            compromised_count = hydra_results.get('compromised_targets', 0)
            total_vulns += compromised_count if isinstance(compromised_count, int) else 0
        
        results['summary'] = {
            'total_vulnerabilities': total_vulns,
            'sql_injection_vulns': sqlmap_results.get('vulnerable_targets', 0) if isinstance(sqlmap_results.get('vulnerable_targets', 0), int) else 0,
            'brute_force_successes': hydra_results.get('compromised_targets', 0) if isinstance(hydra_results.get('compromised_targets', 0), int) else 0
        }
        
        self.logger.info(f"Exploitation completed: {total_vulns} vulnerabilities found")
        self.exploit_results = results
        return results


if __name__ == "__main__":
    # Test the exploiter
    from utils.logger import setup_logging
    
    # Setup logging
    setup_logging(level=10)  # DEBUG level
    
    # Mock scan results for testing
    mock_scan_results = {
        'target': '127.0.0.1',
        'scan_results': {
            '127.0.0.1': {
                'status': 'success',
                'ports': [
                    {'port': '22', 'service': 'ssh'},
                    {'port': '80', 'service': 'http'},
                    {'port': '3306', 'service': 'mysql'}
                ]
            }
        }
    }
    
    exploiter = VulnerabilityExploiter(max_threads=2)
    results = exploiter.run_exploitation(mock_scan_results)
    print(f"Exploitation completed: {results['summary']}") 